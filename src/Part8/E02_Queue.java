package Part8;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
/**
 * @author liyanpeng
 * @date 2025/5/1
 * @description TODO
 */

/**
 * +-------------------------------------------+-------------------------+------------+--------------------------------------------+
 * | 接口 / 类名                                | 类型                    | 线程安全性 | 特徴                                       |
 * +-------------------------------------------+-------------------------+------------+--------------------------------------------+
 * | BlockingQueue<E>                          | インターフェース        | 是         | 支持阻塞操作（put / take）                 |
 * | └── SynchronousQueue<E>                   | クラス（无容量）        | 是         | 每个 put 必须等一个 take（任务交接）       |
 * | ├── LinkedBlockingQueue<E>                | クラス（可选有界）      | 是         | 基于链表的 FIFO 队列（容量可指定）         |
 * | ├── ArrayBlockingQueue<E>                 | クラス（有界）          | 是         | 基于数组的固定长度 FIFO 队列              |
 * <p>
 * ------
 * | ├── PriorityBlockingQueue<E>              | クラス（无界）          | 是         | 按优先级排序（非 FIFO）                    |
 * | ├── DelayQueue<E extends Delayed>         | クラス（无界）          | 是         | 延迟队列，元素到期才可取出                 |
 * +-------------------------------------------+-------------------------+------------+--------------------------------------------+
 * | ConcurrentLinkedQueue<E>                  | クラス（无界）          | 是         | 非阻塞 FIFO 队列，基于 CAS                 |
 * <p>
 * ------
 * | BlockingDeque<E>                          | インターフェース        | 是         | 支持双端阻塞操作                            |
 * | ├── LinkedBlockingDeque<E>                | クラス（可选有界）      | 是         | 双端链表结构的线程安全队列                 |
 * +-------------------------------------------+-------------------------+------------+--------------------------------------------+
 * <p>
 * <p>
 * <p>
 * <p>
 * BlockingQueue
 * +════════════════╦════════════════╦══════════════════════════════╦══════════════════════════════════╦═════════════════════════════════════+
 * | 方法类别       | 方法           | 条件不满足时的行为           | 条件满足时的行为                  | 说明                                |
 * +════════════════╦════════════════╦══════════════════════════════╦══════════════════════════════════╦══════════════════════════════════+
 * | 插入           | add(e)         | 抛出 IllegalStateException   | 成功将元素添加到队列              | 非阻塞，队列满时报错                |
 * |                | offer(e)       | 返回 false                   | 返回 true（成功将元素添加到队列）  | 非阻塞，队列满时失败                |
 * |                | put(e)         | 阻塞（等待空间）             | 成功将元素添加到队列              | 阻塞，直到有空位                   |
 * |                | offer(e,t,unit)| 超时后返回 false             | 返回 true（成功将元素添加到队列）  | 可阻塞等待空间                      |
 * +════════════════╦════════════════╦══════════════════════════════╦══════════════════════════════════╦══════════════════════════════════+
 * | 删除           | remove()       | 抛出 NoSuchElementException  | 成功移除队列头部元素              | 非阻塞，队列空时报错                |
 * |                | poll()         | 返回 null                    | 返回并删除队列头部的元素          | 非阻塞，队列空时失败                |
 * |                | take()         | 阻塞（等待元素）             | 返回并删除队列头部的元素          | 阻塞，直到有元素                   |
 * |                | poll(t,unit)   | 超时后返回 null              | 返回并删除队列头部的元素          | 可阻塞等待元素                      |
 * +════════════════╦════════════════╦══════════════════════════════╦══════════════════════════════════╦══════════════════════════════════+
 * | 检查           | element()      | 抛出 NoSuchElementException  | 查看队列头部元素                  | 队列空时报错                        |
 * |                | peek()         | 返回 null                    | 查看队列头部元素                  | 非阻塞，队列空时返回 null           |
 * +════════════════╩════════════════╩══════════════════════════════╩══════════════════════════════════╩══════════════════════════════════+
 * <p>
 * BlockingDeque
 * +════════════════╦════════════════╦══════════════════════════════╦════════════════════════════════════╦══════════════════════════════════════+
 * | 方法类别       | 方法           | 条件不满足时的行为           | 条件满足时的行为                    | 说明                                   |
 * +════════════════╬════════════════╬══════════════════════════════╬════════════════════════════════════╬══════════════════════════════════════+
 * | 插入（前端）   | addFirst(e)     | 抛出 IllegalStateException   | 成功将元素添加到前端                | 非阻塞，满时报错                         |
 * |                | offerFirst(e)   | 返回 false                   | 返回 true（成功添加）                | 非阻塞，满时失败                         |
 * |                | putFirst(e)     | 阻塞（等待空间）             | 成功将元素添加到前端                | 阻塞直到有空间                          |
 * |                | offerFirst(e,t,unit) | 超时后返回 false        | 返回 true（成功添加）                | 可阻塞等待空间                          |
 * +════════════════╬════════════════╬══════════════════════════════╬════════════════════════════════════╬══════════════════════════════════════+
 * | 插入（后端）   | addLast(e)      | 抛出 IllegalStateException   | 成功将元素添加到后端                | 非阻塞，满时报错                         |
 * |                | offerLast(e)    | 返回 false                   | 返回 true（成功添加）                | 非阻塞，满时失败                         |
 * |                | putLast(e)      | 阻塞（等待空间）             | 成功将元素添加到后端                | 阻塞直到有空间                          |
 * |                | offerLast(e,t,unit) | 超时后返回 false        | 返回 true（成功添加）                | 可阻塞等待空间                          |
 * +════════════════╬════════════════╬══════════════════════════════╬════════════════════════════════════╬══════════════════════════════════════+
 * | 删除（前端）   | removeFirst()   | 抛出 NoSuchElementException  | 成功移除前端元素                    | 非阻塞，空时报错                         |
 * |                | pollFirst()     | 返回 null                    | 返回并删除前端元素                  | 非阻塞，空时失败                         |
 * |                | takeFirst()     | 阻塞（等待元素）             | 返回并删除前端元素                  | 阻塞直到有元素                          |
 * |                | pollFirst(t,unit)| 超时后返回 null             | 返回并删除前端元素                  | 可阻塞等待元素                          |
 * +════════════════╬════════════════╬══════════════════════════════╬════════════════════════════════════╬══════════════════════════════════════+
 * | 删除（后端）   | removeLast()    | 抛出 NoSuchElementException  | 成功移除后端元素                    | 非阻塞，空时报错                         |
 * |                | pollLast()      | 返回 null                    | 返回并删除后端元素                  | 非阻塞，空时失败                         |
 * |                | takeLast()      | 阻塞（等待元素）             | 返回并删除后端元素                  | 阻塞直到有元素                          |
 * |                | pollLast(t,unit)| 超时后返回 null              | 返回并删除后端元素                  | 可阻塞等待元素                          |
 * +════════════════╬════════════════╬══════════════════════════════╬════════════════════════════════════╬══════════════════════════════════════+
 * | 检查           | getFirst()      | 抛出 NoSuchElementException  | 返回前端元素（不删除）              | 查看头部元素，空时报错                  |
 * |                | peekFirst()     | 返回 null                    | 返回前端元素（不删除）              | 非阻塞，空时返回 null                   |
 * |                | getLast()       | 抛出 NoSuchElementException  | 返回后端元素（不删除）              | 查看尾部元素，空时报错                  |
 * |                | peekLast()      | 返回 null                    | 返回后端元素（不删除）              | 非阻塞，空时返回 null                   |
 * +════════════════╩════════════════╩══════════════════════════════╩════════════════════════════════════╩══════════════════════════════════════+
 * <p>
 * java.util.Queue<E>
 * ▲
 * │
 * ┌──────────────────┼───────────────────┐
 * │                                      │
 * java.util.Deque<E>                  java.util.concurrent.BlockingQueue<E>
 * ▲                                      ▲
 * │                                      │
 * └────────────┬─────────────────────────┘
 * │
 * java.util.concurrent.BlockingDeque<E>
 * ▲
 * │
 * java.util.concurrent.LinkedBlockingDeque<E>
 * <p>
 * LinkedBlockingDeque可以使用queue所以接口的方法
 */


public class E02_Queue {
    // 自动生成 main 方法
    public static void main(String[] args) {
        // TODO
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(2);  // 容量为2的小队列

        // 生产者线程
        Thread producer = new Thread(() -> {
            try {
                String[] items = {"🍎", "🍌", "🍇"};
                for (String item : items) {
                    // 尝试在2秒内放入队列
                    if (queue.offer(item, 2, TimeUnit.SECONDS)) {
                        System.out.println("生产者放入: " + item);
                    } else {
                        System.out.println("队列满，放入失败: " + item);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 消费者线程
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 3; i++) {
                    // 尝试在3秒内获取队列中的元素
                    String item = queue.poll(3, TimeUnit.SECONDS);
                    if (item != null) {
                        System.out.println("消费者取出: " + item);
                    } else {
                        System.out.println("队列空，获取失败");
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        producer.start();
        consumer.start();
        /**
         * 生产者放入: 🍎
         * 生产者放入: 🍌
         * 消费者取出: 🍎
         * 生产者放入: 🍇
         * 消费者取出: 🍌
         * 消费者取出: 🍇
         */
    }
}