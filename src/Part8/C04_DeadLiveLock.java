package Part8;

/**
 * @author liyanpeng
 * @date 2025/5/1
 * @description TODO
 */

/**
 * 🔒 デッドロック（Deadlock，死锁）
 * 🧩 定义：
 * 多个线程互相等待对方持有的资源，导致所有线程都无法继续执行。
 * <p>
 * 🧠 发生条件（四个必须同时满足）：
 * 互斥条件：资源只能被一个线程占有。
 * 保持并等待：线程持有资源的同时申请其他资源。
 * 不可剥夺：已分配资源不能强行从线程中剥夺。
 * 循环等待：两个或多个线程形成资源等待的闭环。
 * <p>
 * 线程 A                    线程 B
 * |                          |
 * |--- 获取资源 R1 --------->|   R1 被 A 持有
 * |                          |
 * |                          |--- 获取资源 R2 --------->|
 * |                          |                           R2 被 B 持有
 * |                          |
 * |<-- 等待资源 R2 ----------|   A 等待 B 释放 R2
 * |                          |
 * |                          |<-- 等待资源 R1 ----------  B 等待 A 释放 R1
 * <p>
 * 🔒 两个线程互相等待 → 死锁
 * <p>
 * <p>
 * 🔁 ライブロック（Livelock，活锁）
 * 🧩 定义：
 * 多个线程不断让出资源给对方，但始终没有线程能够完成任务。表现为线程持续运行，但进展为零。
 * <p>
 * 💡 类比说明：
 * 两人相遇让路，A 向左，B 也向左；然后都向右，又重复，结果谁也过不去。
 * 💥 输出：
 * 两人不断「让」勺子给对方，谁也不吃 —— 程序运行着但没有进展。
 * <p>
 * 线程 A                    线程 B
 * |                          |
 * |---> 你先用吧             |
 * |                          |---> 你先用吧
 * |<--- 好的那你先           |<--- 不不你先
 * |---> 哎呀那你来           |---> 哎呀我再等一下
 * |                          |
 * 🔄 不断互相礼让 → 没人真正执行 → 活锁
 * <p>
 * <p>
 * ✅ 区别总结：
 * 特征	       デッドロック (死锁)	     ライブロック (活锁)
 * 状态	       所有线程都停止（卡住）	所有线程都活着（不断运行）
 * CPU 占用	   几乎为零	            较高，因为线程在忙碌地重试
 * 难发现程度	   容易检测（线程不动）	难以检测（线程一直运行）
 * 常见原因	   资源循环等待	        线程不断放弃资源互相礼让
 * <p>
 * <p>
 * <p>
 * <p>
 * 🔒 锁饥饿（Lock Starvation）とは
 * 锁饥饿是指：
 * 某个线程长时间无法获得锁资源，迟迟得不到执行机会，即使它本身是可执行的。
 * <p>
 * 🎯 发生原因
 * 优先度不公平调度
 * 高优先度线程频繁抢占锁，导致低优先度线程长期等待。
 * <p>
 * synchronized 与 notify 使用不当
 * 被 notify() 唤醒的线程并不一定是等待最久的那个。
 * <p>
 * 锁长期被占用
 * 如果有个线程占用锁很久，其他线程就一直进不去。
 * <p>
 * 使用不公平锁（默认）
 * Java 默认的锁机制（如 ReentrantLock）是非公平的，不保证先来先执行。
 * public class StarvationExample {
 * private final Object lock = new Object();
 * <p>
 * public void longRunningTask() {
 * synchronized (lock) {
 * try {
 * Thread.sleep(10000); // 占用锁很久
 * } catch (InterruptedException e) {}
 * }
 * }
 * <p>
 * public void quickTask() {
 * synchronized (lock) {
 * System.out.println(Thread.currentThread().getName() + " 执行 quickTask");
 * }
 * }
 * }
 * 如果有一个线程一直在执行 longRunningTask()，其他线程即使只是想做 quickTask()，也会长期无法获得锁。
 * <p>
 * ✅ 解决方式
 * 使用 ReentrantLock 的公平模式（new ReentrantLock(true)）
 * 控制锁持有时间，避免长时间占用
 * 使用 线程池或信号量机制合理调度
 * 限制线程优先度差异
 * 减少lock回数
 * <p>
 * <p>
 * ================== 锁饥饿示意图 ==================
 * <p>
 * 线程 A        线程 B        线程 C        线程 D
 * ↓             ↓             ↓             ↓
 * 请求锁        请求锁        请求锁        请求锁
 * ↓             ↓             ↓             ↓
 * 获得锁（长期占用）
 * ↓
 * 执行中...
 * ↓
 * 执行中...
 * ↓
 * （其他线程一直等待）
 * （等待）
 * （等待）
 * （等待）
 * <p>
 * 说明：
 * - 线程 A 占用了锁（执行任务时间很长）
 * - B/C/D 一直在等待，始终得不到锁的执行机会
 * → 就产生了「锁饥饿」
 * 如果线程 A 是高优先度，调度系统又总是优先安排它执行，就会导致低优先度线程 B/C/D 一直被饿住，不能执行。
 * =================================================
 */
public class C04_DeadLiveLock {
    // 自动生成 main 方法
    public static void main(String[] args) {
        // TODO
    }
}