package Part8;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author liyanpeng
 * @date 2025/5/3
 * @description TODO
 */

/**
 * +------------------+---------------------------------------------------------+
 * |  方法签名        |  groupByConcurrent(Function<? super T, ? extends K> classifier) |
 * |                  |  groupByConcurrent(Function classifier, Collector downstream) |
 * |                  |  groupByConcurrent(Function classifier, Supplier mapFactory, |
 * |                  |                                Collector downstream)        |
 * +------------------+---------------------------------------------------------+
 * |  功能说明        |  将元素按指定分类函数分组到线程安全的ConcurrentMap中        |
 * |                  |  返回ConcurrentMap<K, List<V>>结构                        |
 * +------------------+---------------------------------------------------------+
 * |  典型用途        |  并行流中的高效分组操作                                  |
 * |                  |  替代普通groupBy以提升并行性能                           |
 * +------------------+---------------------------------------------------------+
 * |  特性            |  - 自动使用ConcurrentHashMap实现                        |
 * |                  |  - 键不允许为null                                      |
 * |                  |  - 支持下游收集器（如counting/summing等）               |
 * +------------------+---------------------------------------------------------+
 * |  示例代码        |  ConcurrentMap<String, List<Employee>> byDept =          |
 * |                  |      employees.parallelStream()                        |
 * |                  |      .collect(groupByConcurrent(Employee::getDept));    |
 * +------------------+---------------------------------------------------------+
 * <p>
 * <p>
 * +------------------+---------------------------------------------------------+
 * |  方法签名        |  toConcurrentMap(Function keyMapper, Function valueMapper) |
 * |                  |  toConcurrentMap(Function keyMapper, Function valueMapper, |
 * |                  |                      BinaryOperator mergeFunction)         |
 * |                  |  toConcurrentMap(Function keyMapper, Function valueMapper, |
 * |                  |                      BinaryOperator mergeFunction,         |
 * |                  |                      Supplier mapSupplier)                 |
 * +------------------+---------------------------------------------------------+
 * |  功能说明        |  将元素转换为线程安全的ConcurrentMap键值对                |
 * |                  |  支持自定义键冲突处理策略和Map实现                       |
 * +------------------+---------------------------------------------------------+
 * |  典型用途        |  并行流中构建线程安全的映射表                            |
 * |                  |  需要处理重复键的场景                                   |
 * +------------------+---------------------------------------------------------+
 * |  特性            |  - 默认使用ConcurrentHashMap实现                        |
 * |                  |  - 键和值都不允许为null                                |
 * |                  |  - 不指定mergeFunction时重复键会抛出异常                |
 * +------------------+---------------------------------------------------------+
 * |  示例代码        |  ConcurrentMap<Integer, String> idToName =              |
 * |                  |      employees.parallelStream()                        |
 * |                  |      .collect(toConcurrentMap(                         |
 * |                  |          Employee::getId,                              |
 * |                  |          Employee::getName,                            |
 * |                  |          (oldVal, newVal) -> oldVal));                 |
 * +------------------+---------------------------------------------------------+
 * <p>
 * <p>
 * <p>
 * +------------------+--------------------------------+--------------------------------+
 * |     比较项       |      groupByConcurrent         |          groupBy               |
 * +==================+================================+================================+
 * |  返回类型        |  ConcurrentMap<K, List<V>>     |  Map<K, List<V>>               |
 * +------------------+--------------------------------+--------------------------------+
 * |  线程安全性      |  内置线程安全                  |  非线程安全                    |
 * +------------------+--------------------------------+--------------------------------+
 * |  底层实现        |  ConcurrentHashMap             |  HashMap                       |
 * +------------------+--------------------------------+--------------------------------+
 * |  并行流性能      |  更高（无锁竞争）              |  较低（需同步）                |
 * +------------------+--------------------------------+--------------------------------+
 * |  顺序流性能      |  较低（有不必要同步开销）      |  更高                          |
 * +------------------+--------------------------------+--------------------------------+
 * |  典型用例        |  并行流分组统计                |  顺序流分组统计                |
 * +------------------+--------------------------------+--------------------------------+
 * |  空值处理        |  不允许null键                 |  不允许null键                 |
 * +------------------+--------------------------------+--------------------------------+
 * |  下游收集器支持  |  支持                        |  支持                        |
 * +------------------+--------------------------------+--------------------------------+
 * <p>
 * <p>
 * <p>
 * +------------------+--------------------------------+--------------------------------+
 * |     比较项       |      toConcurrentMap           |          toMap                 |
 * +==================+================================+================================+
 * |  返回类型        |  ConcurrentMap<K,V>           |  Map<K,V>                     |
 * +------------------+--------------------------------+--------------------------------+
 * |  线程安全性      |  内置线程安全                  |  非线程安全                    |
 * +------------------+--------------------------------+--------------------------------+
 * |  底层实现        |  ConcurrentHashMap             |  HashMap                       |
 * +------------------+--------------------------------+--------------------------------+
 * |  并行流性能      |  更高（无锁竞争）              |  较低（需同步）                |
 * +------------------+--------------------------------+--------------------------------+
 * |  顺序流性能      |  较低（有不必要同步开销）      |  更高                          |
 * +------------------+--------------------------------+--------------------------------+
 * |  典型用例        |  并行流构建映射                |  顺序流构建映射                |
 * +------------------+--------------------------------+--------------------------------+
 * |  空值处理        |  不允许null键/值              |  不允许null键/值              |
 * +------------------+--------------------------------+--------------------------------+
 * |  重复键处理      |  可指定merge函数              |  可指定merge函数              |
 * +------------------+--------------------------------+--------------------------------+
 * |  Map工厂支持     |  支持                        |  支持                        |
 * +------------------+--------------------------------+--------------------------------+
 */
public class H04_Pipeline_groupByConcurrent_toConcurrentMap {
    // 自动生成 main 方法
    public static void main(String[] args) {
        // TODO
        Stream<String> stream1 =
                Stream.of("belle", "akko", "ami", "bob", "nao").parallel();
        Map<String, List<String>> map1 =
                stream1.collect(Collectors.groupingByConcurrent(
                        s -> s.substring(0, 1)));
        System.out.println(map1);
        System.out.println("map1のクラス名 :" + map1.getClass());

        Stream<String> stream2 =
                Stream.of("nao", "akko", "ami").parallel();
        Map<Integer, String> map2 =
                stream2.collect(Collectors.toConcurrentMap(
                        String::length,
                        s -> s,
                        (s1, s2) -> s1 + " : " + s2));
        System.out.println(map2);
        System.out.println("map2のクラス名 :" + map2.getClass());

        /**
         * {a=[ami, akko], b=[belle, bob], n=[nao]}
         * map1のクラス名 :class java.util.concurrent.ConcurrentHashMap
         * {3=ami : nao, 4=akko}
         * map2のクラス名 :class java.util.concurrent.ConcurrentHashMap
         */
    }
}