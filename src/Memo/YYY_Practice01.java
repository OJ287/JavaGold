package Memo;

/**
 * @author liyanpeng
 * @date 2025/5/14
 * @description TODO
 */

/**
 * ✅第N章
 * <p>
 * 答え：
 * 1:
 * 2:
 * 3:
 * 4:
 * 5:
 * 6:
 * 7:
 * 8:
 * 9:
 * 10:
 * 11:
 * 12:
 * 13:
 * 14:
 * 15:
 */

/**
 *
 * ✅第1章:15'30''
 *
 * 答え：
 * 	1:ADE
 *  2:A
 *  3:D
 *  4:C
 *  5:D
 *  6:AE    →    BE
 *  7:E
 *  8:ABDE
 *  9:E
 *  10:A    →    E
 *  11:C
 *  12:E
 *  13:E
 *  14:E
 *  15:ACD    →    ABE
 */

/**
 *
 * ✅第2章
 *
 * 答え：
 * 	1:E
 *  2:F
 *  3:CE
 *  4:D
 *  5:C
 *  6:C
 *  7:AB    →    BE
 *  8:CE
 */

/**
 *
 * ✅第3章
 *
 * 答え：
 * 	1:BD
 *  2:AC
 *  3:AB
 *  4:B    →    D
 *  5:BCE
 *  6:B
 *  7:E
 *  8:CDE
 *  9:E
 *  10:F
 *  11:CE
 *  12:BE
 *  13:D
 */


/**
 *
 * ✅第4章
 *
 * 答え：
 * 	1:D
 *  2:C
 *  3:E
 *  4:AD
 *  5:AE
 *  6:AD
 *  7:B
 *  8:C
 *  9:E    →    C
 *  10:E
 *  11:AE
 *  12:CD    →    BC
 *  13:BDF
 *  14:E    →    A
 *  15:C    →    A
 */

/**
 *
 * ✅第5章
 *
 * 答え：
 * 	1:BE
 *  2:BCG
 *  3:B
 *  4:ADF
 *  5:A
 *  6:AF
 *  7:C
 *  8:BF
 *  9:B
 *  10:E    →    A
 *  11:C
 */

/**
 *
 * ✅第6章
 *
 * 答え：
 * 	1:AB    →    BE
 *  2:CEF
 *  3:F
 *  4:EF
 *  5:D
 *  6:E
 *  7:C    →    F
 *  8:AD
 *  9:A
 *  10:C
 *  11:BF
 *  12:E
 *  13:D
 *  14:ABF
 *  15:B    →    C
 *  16:A    →    D
 *  17:A
 *  18:AE    →    BF
 *  19:AD    →    AB
 *  20:D
 */


/**
 *
 * ✅第7章
 *
 * 答え：
 * 	1:D
 *  2:AE
 *  3:B
 *  4:A
 *  5:A
 *  6:BD
 *  7:ADF
 *  8:B
 *  9:C
 *  10:BE
 *  11:D    →    E
 */


/**
 *
 * ✅第8章
 *
 * 答え：
 * 	1:AE
 *  2:A    →    D
 *  3:BF
 *  4:A    →    C
 *  5:D
 *  6:C    →    D
 *  7:DF
 *  8:BEFG
 *  9:ACE
 *  10:C
 *  11:A
 *  12:D    →    E
 *  13:CD
 *  14:AD
 *  15:B
 *  16:E    →    D
 */


/**
 *
 * ✅第9章
 *
 * 答え：
 * 	1:BE
 *  2:D
 *  3:E
 *  4:CF
 *  5:ACE
 *  6:AD
 *  7:ACE
 *  8:A
 *  9:DF    →    DE
 *  10:AC
 *  11:ACE
 *  12:E
 *  13:ACE
 *  14:C
 *  15:A    →    B
 *  16:BC
 *  17:A
 *  18:D    →    C
 *  19:C
 *  20:CE    →    BC
 *  21:A    →    D
 *  22:E
 *  23:C
 */


/**
 *
 * ✅第10章
 *
 * 答え：
 * 	1:DE
 *  2:D    →    E
 *  3:C
 *  4:ACD
 *  5:D
 *  6:B    →    E
 *  7:E
 *  8:E
 *  9:DE
 *  10:F
 *  11:A
 *  12:C
 *  13:E
 */


/**
 *
 * ✅11章
 *
 * 答え：
 * 	1:AD
 *  2:D
 *  3:C
 *  4:C
 *  5:AC
 *  6:D
 *  7:F
 *  8:C
 *  9:B    →    F
 *  10:A    →    F
 *  11:D
 *  12:C
 *  13:E
 */


/**
 *
 * ✅第12章
 *
 * 答え：
 * 	1:B
 *  2:C
 *  3:D
 *  4:CD
 *  5:D
 *  6:F
 *  7:E
 *  8:BE
 */

import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * ✅✅✅总结
 * 共165
 * 错31
 * 错误率:18.8%
 * 正确率:81.2%
 *
 * 15.    3
 * 7.      1
 * 13.    1
 * 15.    4
 * 11.    1
 * 20.   6
 * 11.   1
 * 16.   5
 * 23.   5
 * 13.   2
 * 13.   2
 * 8.     0
 */
public class YYY_Practice01 {
    // 自动生成 main 方法
    public static void main(String[] args) {
        // TODO
        Path path1 = Paths.get(".").normalize();

        System.out.println("Path: '" + path1 + "'");  // 加引号显示空白
        System.out.println("Name count: " + path1.getNameCount());
        System.out.println("Is empty: " + path1.toString().isEmpty());
        System.out.println("Is absolute: " + path1.isAbsolute());
        System.out.println("Absolute path: " + path1.toAbsolutePath());
        /**
         * 虽然Paths.get(".").normalize();返回的是空，但是为了当前路径和完全空路径区分开，count也是认为是1个元素
         * Path: ''
         * Name count: 1
         * Is empty: true
         * Is absolute: false
         * Absolute path: /Users/liyanpeng/IdeaProjects/JavaGold
         */


        Path a = Paths.get("/food/../orange.txt");
        Path b = Paths.get("./lemon.txt");
        System.out.println(a.resolve(b));
        System.out.println(b.resolve(a));


        String[] words = {"banana", "orange", "apple", "lemon"};
        Integer[] numbers = {1, 2, 3, 4, 5};
        CustomType type = new CustomType();          // 原始类型（无泛型）
        CustomType<String> stringType = new CustomType<>();

        System.out.println(stringType.count(words, "apple")); // 调用1
        System.out.println(type.count(words, "apple"));        // 调用2
        System.out.println(type.count(numbers, 3));            // 调用3
    }


}

class CustomType<T> {
    public <T> int count(T[] anArray, T element) {
        int count = 0;
        for (T e : anArray) {
            if (e.equals(element)) ++count;
        }
        return count;
    }
}