package Part9;

/**
 * @author liyanpeng
 * @date 2025/5/5
 * @description TODO
 */
/**
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * |          ⚠️ 序列化处理注意点总结（Serialization 注意事项）         |                          说明                                |
 * +============================================================+=============================================================+
 * | 数组或集合类序列化                                          | 内部元素也必须实现 Serializable，整个结构可被序列化           |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 被序列化的对象引用了其他对象 → 那些对象也必须实现 Serializable | 否则也会抛出 NotSerializableException 异常                    |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | static 字段不会被序列化                                     | 因为 static 属于类，不属于对象实例                           |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | transient 修饰的字段不会被序列化                            | 用于敏感数据（如密码），或无需保存的临时数据                   |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 父类已实现 Serializable                                    | 子类可不用声明也可序列化                                     |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 父类未实现 Serializable                                     | 父类中的字段不会被序列化，反序列化时会通过默认构造函数恢复       |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 子类实现 Serializable、父类未实现                          | 父类的字段不会被保存，反序列化时会调用父类的无参构造函数。父类必须有无参构造函数，且其字段会被初始化为默认值/构造函数设置的值       |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 类必须实现 java.io.Serializable 接口                        | 否则在 ObjectOutputStream.writeObject() 时会抛出异常          |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 构造函数与序列化无直接关系                                  | 反序列化不会调用构造函数（会通过 JVM 特殊机制直接构建对象）     |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 反序列化后对象 hashCode 会变化                              | 因为是新建的对象，若需要相等判断请自行实现 equals/hashCode 方法 |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 * | 类的 serialVersionUID 推荐手动指定                          | 用于版本控制，避免类结构微调后反序列化失败                     |
 * +------------------------------------------------------------+-------------------------------------------------------------+
 */

import java.io.*;

class Foo1 {
    int a;

    Foo1() {
        a = 10;
        System.out.println("Foo1()");
    }
}

class Bar1 extends Foo1 implements Serializable {
    int b;

    Bar1() {
        b = 100;
        System.out.println("Bar1()");
    }
}

public class C04_Serializable_Extends {
    // 自动生成 main 方法
    public static void main(String[] args) {
        // TODO
        Bar1 bar = new Bar1();
        bar.a = 100;
        bar.b = 100;
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("src/Part9/data_C04_1.txt"));
             ObjectInputStream ois = new ObjectInputStream(
                     new FileInputStream("src/Part9/data_C04_1.txt"))) {
            oos.writeObject(bar); // シリアライズ
            Bar1 readBar = (Bar1) ois.readObject(); // デシリアライズ
            System.out.println("readBar.a + : " + readBar.a);
            System.out.println("readBar.b + : " + readBar.b);
        } catch (ClassNotFoundException | IOException e) {
            e.printStackTrace();
        }
        /**
         * Foo1()
         * Bar1()
         * Foo1()       // 反序列化时额外调用
         * readBar.a + : 10   // a被重置为10（而非序列化前的100）
         * readBar.b + : 100
         */
        /**
         * 2. 根本原因
         * 当反序列化一个继承自不可序列化父类（Foo1）的对象时：
         * １、父类字段不会自动序列化
         * 因为 Foo1 未实现 Serializable，其字段 a 不会被保存到字节流中。
         * ２、JVM 必须重建父类部分
         * 反序列化时会：
         * 调用父类的无参构造函数重新初始化父类部分
         * 仅从流中恢复子类（Bar1）的序列化字段
         * 3. 代码执行流程
         *序列化时:
         * Bar1(父类Foo1) → 仅保存子类Bar1的字段b的值(100)
         *
         * 反序列化时:
         * 1. 调用Foo1()构造函数 → 初始化a=10
         * 2. 从流中恢复Bar1的字段b=100
         *
         * Java规范说明
         * 如果反序列化的对象的类有不可序列化的父类，则该父类必须有无参构造函数，且其字段会被初始化为默认值/构造函数设置的值。
         *
         * 7. 最佳实践建议
         * 要么让整个继承链都可序列化
         * 要么显式处理父类字段的序列化
         * 避免混合使用（部分可序列化/部分不可序列化）
         *
         */
    }
}